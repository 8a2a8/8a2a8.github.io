---
title: 进程间通信
date: 2023-05-28 09:43:16 +/-TTTT
categories: [IPC, cpp]
tags: [IPC, cpp, c]
---

# 目的
- 分析进程间通信方式以及使用案例

# 总结
进程间共有以下几种通信方式：
- 管道
- FIFO
- 消息队列
- 信号量
- 共享内存

它们之间的优缺点：

- 管道：速度慢，容量有限，只有父子进程能通讯
- FIFO：与管道类似，区别在于任何进程间都能通讯
- 消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题
- 信号量：不能传递复杂消息，只能用来同步
- 共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存

# 共享内存
## 原理
共享内存是基于内存映射实现的，所以需要先说明什么是内存映射

内存映射是我们平常所使用的mmap系统调用，可以将文件映射进内润，直接以内存的方式访问文件，数据库通常也采用这种方式加载文件，以减少内核层管理耗时。

说回整体，共享内存则是基于内存的文件系统之上，创建一个内存文件，然后进行映射，由于是内存型的文件系统，所以不涉及磁盘IO，是纯粹的内存访问

## mmap系统调用示例

## 总结
综上，共享内存其实就是做了两个步骤：
1. 创建一篇vma管理共享内存区域，并初始化相应的数据结构，然后关联上一个文件
2. 当发生缺页中断时，通过文件来获取相应的页（也即物理内存），所有使用这片共享内存的进程都是通过同一个文件来获取页，达到共享的目的
shmget

通过shmget获得的共享内存，其本质上也是创建内存文件，然后做mmap，只是内核封装了一个key的系统，屏蔽了许多细节

# FIFO
## 什么是FIFO
- `命名管道`也被称为`FIFO`，它是一种特殊类型的文件，它在文件系统中以文件名的形式存在，但是它的行为却和没有名字的匿名管道类似。

- 由于Linux中所有的事物都可被视为文件，所以对命名管道的使用也就变得与文件操作非常的统一，也使它的使用非常方便，同时我们也可以像平常的文件名一样在命令中使用。

## 使用方式
我们可以使用两下函数之一来创建一个命名管道，他们的原型如下：

```c
#include <sys/types.h>
#include <sys/stat.h>
int mkfifo(const char *filename, mode_t mode);
int mknod(const char *filename, mode_t mode | S_IFIFO, (dev_t)0);
```
这两个函数都能创建一个FIFO文件，注意是创建一个真实存在于文件系统中的文件，filename指定了文件名，而mode则指定了文件的读写权限。

mknod是比较老的函数，而使用mkfifo函数更加简单和规范，所以建议在可能的情况下，尽量使用mkfifo而不是mknod。

## 使用案例
### 1. mydumper
- **使用逻辑：** 使用命名管道实现压缩数据文件无需创建临时文件进行恢复

## 参考文献
- [mkfifo](https://www.man7.org/linux/man-pages/man3/mkfifo.3.html)
- [Linux进程间通信fifo](https://www.cnblogs.com/52php/p/5840229.html)